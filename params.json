{"name":"Vitali","tagline":"vitali is yet another web framework for Go","body":"vitali\r\n======\r\n## Install\r\nMake sure you have configured the go runtime correctly first.\r\n\r\n```\r\n$ go get github.com/lunastorm/vitali\r\n```\r\n\r\n## Run example\r\n```\r\n$ cd $GOPATH/src/github.com/lunastorm/vitali/example\r\n$ go run main.go\r\n2014/04/11 01:50:22 starting server at port 8080...\r\n```\r\n\r\nOpen http://foo:bar@127.0.0.1:8080/user/foo/slide in the browser, and you can create a new slide or edit the example slide.\r\n\r\n## Basic webapp folder structure\r\nYou can place almost everything in the base folder. However, you should create the \"views\" subfolder which is where you put the template html files, and also the i18n.json dictionary.\r\n\r\n## Create your first resource\r\nresources/foo.go\r\n```\r\npackage resources\r\nimport (\r\n    \"github.com/lunastorm/vitali\"\r\n)\r\n\r\ntype Foo struct {\r\n    vitali.Ctx\r\n}\r\n\r\nfunc (c *Foo) Get() interface{} {\r\n    return \"hello world\"\r\n}\r\n```\r\nEvery resource struct should embed the _vitali.Ctx_ struct. Then you implement the GET or other methods for it.\r\n\r\n## Serve the webapp\r\nmain.go\r\n```\r\npackage main\r\n\r\nimport (\r\n    \"log\"\r\n    \"net/http\"\r\n    \"github.com/lunastorm/vitali\"\r\n    \"./resources\"\r\n)\r\n\r\nfunc main() {\r\n    http.Handle(\"/static/\", http.StripPrefix(\"/static/\", http.FileServer(http.Dir(\"./static\"))))\r\n    webapp := vitali.CreateWebApp([]vitali.RouteRule{\r\n        {\"/foo\", resources.Foo{\r\n        }}, \r\n    })  \r\n    http.Handle(\"/\", webapp)\r\n    log.Printf(\"starting server at port 8080...\")\r\n    http.ListenAndServe(\":8080\", nil)\r\n}\r\n```\r\n\r\n## Routing\r\nThe first member of vitali.RouteRule is the path expression, and the second is the target resource's prototype instance. _{thisPresentsAPathParameter}_ You can access the path parameter through the PathParam method, here is an example:\r\n```\r\nwebapp := vitali.CreateWebApp([]vitali.RouteRule{\r\n    {\"/image/{filename}\", resources.Image{\r\n    }},\r\n})\r\n\r\ntype Image struct {\r\n    vitali.Ctx\r\n}\r\n\r\nfunc (c *Image) Get() interface{} {\r\n    f, _ := os.Open(\"images/\"+c.PathParam(\"filename\"))\r\n    return f\r\n}\r\n```\r\n\r\n## Method Dispatching\r\nImplement the methods that returns anything (type interface{}) which corresponds to the HTTP methods.\r\n\r\nPre() is a special function that runs before the HTTP methods if implemented. You can do some initialization and checking in Pre(). Returning nil in Pre() means to continue to invoke the corresponding HTTP method.\r\n```\r\ntype Foo struct {\r\n    vitali.Ctx\r\n}\r\n\r\nfunc (c *Foo) Get() interface{}\r\nfunc (c *Foo) Post() interface{}\r\nfunc (c *Foo) Put() interface{}\r\nfunc (c *Foo) Delete() interface{}\r\nfunc (c *Foo) Pre() interface{}\r\n```\r\n\r\n## Predefined Response Types\r\nSome typical HTTP responses are provided. See https://github.com/lunastorm/vitali/blob/master/response_types.go\r\n\r\nFor example,\r\n```\r\nfunc (c *Foo) Pre() interface{} {\r\n    return c.BadRequest(\"bad!\")\r\n}\r\n\r\nfunc (c *Foo) Get() interface{} {\r\n    return c.NotFound()\r\n}\r\n```\r\n\r\n## Authentication\r\nYou can provide your customized user and role provider when you implement vitali.UserProvider interface, and then setup the user provider as follows:\r\n```\r\ntype UserProvider interface {\r\n    AuthHeader(*http.Request) string\r\n    GetUserAndRole(*http.Request) (string, string)\r\n}\r\n\r\nwebapp.UserProvider = &YourUserProvider{...}\r\n```\r\n\r\n### Authentication Example: HTTP Basic Authentication\r\nThis example just verifies that the  username is _foo_ and the password is _bar_. And the role _AUTHED_ will be added when the user is authenticated.\r\n```\r\nimport (\r\n    \"strings\"\r\n    \"net/http\"\r\n    \"encoding/base64\"\r\n)\r\n\r\ntype UserProvider struct {\r\n}\r\n\r\nfunc (c *UserProvider) AuthHeader(r *http.Request) (WWWAuthenticate string) {\r\n    return `Basic realm=\"vitali\"`\r\n}\r\n\r\nfunc (c *UserProvider) GetUserAndRole(r *http.Request) (user string, role string) {\r\n    authHeader := r.Header.Get(\"Authorization\")\r\n    if !strings.HasPrefix(authHeader, \"Basic \") {\r\n        return\r\n    }   \r\n\r\n    data, err := base64.StdEncoding.DecodeString(strings.SplitN(authHeader, \" \", 2)[1])\r\n    if err != nil {return}\r\n    tmp := strings.SplitN(string(data), \":\", 2)\r\n    user = tmp[0]\r\n    password := tmp[1]\r\n\r\n    if user == \"foo\" && password == \"bar\" {\r\n        return user, \"AUTHED\"\r\n    } else {\r\n        user = \"\"\r\n        return\r\n    }   \r\n}\r\n```\r\n\r\n## vitali.Ctx\r\nThis is embedded in all your resource structs and wraps the original *http.Request and http.ResponseWriter.\r\n```\r\ntype Ctx struct {\r\n    Username    string\r\n    Roles       Roles\r\n    Request *http.Request\r\n    ResponseWriter  http.ResponseWriter\r\n    ChosenType  MediaType\r\n    ChosenLang  string\r\n    ContentType MediaType\r\n}\r\n```\r\nRefer to https://github.com/lunastorm/vitali/blob/master/ctx.go for some convinient methods.\r\n\r\n## vitali.Perm\r\nAn optional member to be embedded in the resource. \r\n\r\nFor example,\r\n```\r\ntype Image struct {\r\n    vitali.Ctx\r\n    vitali.Perm `GET:\"AUTHED\" DELETE:\"ADMIN|OWNER\"`\r\n}\r\n```\r\nmeans that every GET request to Image should be authenticated, and every DELETE requests by roles other than _ADMIN_ or _OWNER_ are forbidden.\r\n\r\nActually you can use any role name you like. You can add roles to an authenticated user in your _UserProvider_ or the _Pre()_ function like this:\r\n```\r\nfunc (c *Image) Pre() interface{} {\r\n    if /* check if c.Username is image's owner */ {\r\n        c.Roles.Add(\"OWNER\")\r\n    }\r\n}\r\n```\r\n\r\n## vitali.Consumes\r\nIt controls which request content types are accepted if specified. For example,\r\n```\r\ntype UserInfo struct {\r\n    vitali.Ctx\r\n    vitali.Consumes `POST:\"application/x-www-form-urlencoded,application/json\"`\r\n}\r\n```\r\nmeans that the POST method only accepts content-type _application/x-www-form-urlencoded_ or _application/json_.\r\n\r\n## vitali.Provides and vitali.Views\r\nThis does the content negotiation with the requester's _Accept_ header.\r\n```\r\ntype UserInfo struct {\r\n    vitali.Ctx\r\n    vitali.Provides `GET:\"application/json,text/html\"`\r\n    vitali.Views `GET:\"base.html,userinfo.html\"`\r\n}\r\n```\r\nThe result returned by the GET method will be serialized to JSON automatically if content type _application/json_ is chosen. If _text/html_ is chosen, it will lookup the struct tag of vitali.Views if defined, and execute the templates with the model returned.\r\n\r\n## Extended Template\r\nOriginally you can only use _{{.}}_ to get the model in the template. vitali moves _{{.}}_ to _{{.M}}_, with .M represents the model.\r\n\r\n_{{.C}}_ lets you access vitali.Ctx in the view, so that you can display something like username in the page by _{{.C.Username}}_\r\n\r\n_{{.S}}_ is the i18n dictionary map. This is how you write the string lables in the template: e.g., _{{.S.SOMELABEL}}_\r\n\r\nYou have to create a file named _i18n.json_ in the _views_ subdirectory like this:\r\n```\r\n{\r\n    \"en-us\": {\r\n        \"SLIDE_NAME\": \"Slide Name\",\r\n        \"CREATE\": \"Create\",\r\n        \"DUPLICATE\": \"Duplicate\",\r\n        \"CREATE_NEW_SLIDE\": \"Create New Slide\"\r\n    },  \r\n    \"zh-tw\": {\r\n        \"SLIDE_NAME\": \"投影片名稱\",\r\n        \"CREATE\": \"新建\",\r\n        \"DUPLICATE\": \"複製\",\r\n        \"CREATE_NEW_SLIDE\": \"建立新投影片\"\r\n    }   \r\n}\r\n```\r\n\r\n## Language Provider\r\nImplement the LangProvider interface and set it in the webapp to select the locale.\r\n\r\nFor example,\r\n```\r\nfunc (c *LangProvider) Select(ctx *vitali.Ctx) (lang string) {\r\n    lang = ctx.Cookie(\"lang\")\r\n    if lang != \"\" {\r\n        return\r\n    }\r\n    lang = \"en-us\"\r\n\r\n    accept := ctx.Header(\"Accept-Language\")\r\n    /*\r\n    process the accept-language header\r\n    */\r\n    ...\r\n}\r\n```\r\n","google":"UA-63183439-1","note":"Don't delete this file! It's used internally to help with page regeneration."}